#!/usr/bin/env bun

import { existsSync, mkdirSync, copyFileSync, writeFileSync } from "fs";
import { join } from "path";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY BUN
if you want to view the source, please visit the github repository of this plugin
https://github.com/karlmdavis/obsidian-operator
*/
`;

const args = process.argv.slice(2);
const prod = args.includes("--production");
const watch = args.includes("--watch");

const buildConfig = {
	entrypoints: ["./src/main.ts"],
	outdir: "./",
	target: "browser",
	format: "cjs" as const,
	sourcemap: prod ? "none" as const : "inline" as const,
	minify: prod,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab", 
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
	],
};

async function build() {
	console.log(prod ? "ðŸ—ï¸  Building for production..." : "ðŸ”¨ Building for development...");
	
	const result = await Bun.build(buildConfig);
	
	if (!result.success) {
		console.error("âŒ Build failed:");
		for (const message of result.logs) {
			console.error(message);
		}
		process.exit(1);
	}

	// Write the output with banner
	const mainOutput = result.outputs.find(output => output.path.endsWith("main.js"));
	if (mainOutput) {
		const content = banner + "\n" + await mainOutput.text();
		await Bun.write("main.js", content);
	}

	// Copy files for development
	if (!prod && process.env.OBSIDIAN_PLUGINS_PATH) {
		const pluginPath = join(process.env.OBSIDIAN_PLUGINS_PATH, "obsidian-operator");
		
		if (!existsSync(pluginPath)) {
			mkdirSync(pluginPath, { recursive: true });
		}
		
		// Copy files to Obsidian plugins directory
		copyFileSync("main.js", join(pluginPath, "main.js"));
		copyFileSync("manifest.json", join(pluginPath, "manifest.json"));
		if (existsSync("styles.css")) {
			copyFileSync("styles.css", join(pluginPath, "styles.css"));
		}
		
		// Touch .hotreload file for hot-reload plugin support
		// Use current timestamp to ensure the file is updated
		writeFileSync(join(pluginPath, ".hotreload"), new Date().toISOString());
		console.log(`âœ“ Copied to ${pluginPath}`);
	}

	console.log("âœ… Build complete!");
}

if (watch) {
	console.log("ðŸ‘€ Watching for changes...");
	
	// Initial build
	await build();
	
	// Watch for changes in src and root files
	const fs = require("fs");
	
	// Watch src directory
	const srcWatcher = fs.watch("./src", { recursive: true }, async (eventType: string, filename: string) => {
		if (filename && (filename.endsWith(".ts") || filename.endsWith(".js"))) {
			console.log(`ðŸ“ ${filename} changed, rebuilding...`);
			await build();
		}
	});
	
	// Watch root files (styles.css, manifest.json)
	const rootFiles = ["styles.css", "manifest.json"];
	rootFiles.forEach(file => {
		if (fs.existsSync(file)) {
			fs.watchFile(file, async () => {
				console.log(`ðŸ“ ${file} changed, rebuilding...`);
				await build();
			});
		}
	});
	
	// Keep process alive
	process.on("SIGINT", () => {
		console.log("\nðŸ‘‹ Stopping watcher...");
		watcher.close();
		process.exit(0);
	});
	
} else {
	await build();
}
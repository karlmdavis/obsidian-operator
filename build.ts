#!/usr/bin/env bun

import { existsSync, mkdirSync, copyFileSync, writeFileSync, accessSync, constants } from "fs";
import { join, dirname } from "path";
import { homedir } from "os";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY BUN
if you want to view the source, please visit the github repository of this plugin
https://github.com/karlmdavis/obsidian-operator
*/
`;

const args = process.argv.slice(2);
const prod = args.includes("--production");
const watch = args.includes("--watch");

/**
 * Validates the build environment and provides helpful error messages.
 * Checks for required tools, directories, environment variables, and plugin manifest.
 */
function validateEnvironment(): void {
	// Check if we're in the right directory (has manifest.json)
	if (!existsSync("manifest.json")) {
		console.error("‚ùå Build failed: manifest.json not found. Are you running from the project root?");
		process.exit(1);
	}

	// Validate manifest.json structure
	try {
		const manifest = require("./manifest.json");
		const requiredFields = ["id", "name", "version", "minAppVersion"];
		
		for (const field of requiredFields) {
			if (!manifest[field]) {
				console.error(`‚ùå Build failed: manifest.json missing required field: ${field}`);
				process.exit(1);
			}
		}
		
		// Validate version format (semver-like)
		if (!/^\d+\.\d+\.\d+/.test(manifest.version)) {
			console.error(`‚ùå Build failed: manifest.json version should follow semver format (x.y.z), got: ${manifest.version}`);
			process.exit(1);
		}
		
	} catch (error) {
		console.error("‚ùå Build failed: Cannot parse manifest.json");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		process.exit(1);
	}

	// Check if source directory exists
	if (!existsSync("src")) {
		console.error("‚ùå Build failed: src directory not found");
		process.exit(1);
	}

	// Check if main entry point exists
	if (!existsSync("src/main.ts")) {
		console.error("‚ùå Build failed: src/main.ts not found");
		process.exit(1);
	}

	// For development builds with copying, validate OBSIDIAN_PLUGINS_PATH
	if (!prod && process.env.OBSIDIAN_PLUGINS_PATH) {
		const pluginsPath = process.env.OBSIDIAN_PLUGINS_PATH;
		
		try {
			// Check if the parent directory exists and is writable
			accessSync(dirname(pluginsPath), constants.F_OK | constants.W_OK);
		} catch (error) {
			console.error(`‚ùå Environment setup error: OBSIDIAN_PLUGINS_PATH parent directory is not accessible:`);
			console.error(`   Path: ${dirname(pluginsPath)}`);
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			console.error(`   Suggestion: Check that the path exists and you have write permissions`);
			process.exit(1);
		}
	}
}

/**
 * Safely copies a file with error handling and helpful error messages.
 * Creates parent directories if they don't exist.
 */
function safeCopyFile(source: string, destination: string): boolean {
	try {
		// Ensure destination directory exists
		const destDir = dirname(destination);
		if (!existsSync(destDir)) {
			mkdirSync(destDir, { recursive: true });
		}

		// Check if source file exists
		if (!existsSync(source)) {
			console.warn(`‚ö†Ô∏è  Warning: Source file ${source} does not exist, skipping copy`);
			return false;
		}

		// Perform the copy
		copyFileSync(source, destination);
		return true;
	} catch (error) {
		console.error(`‚ùå Failed to copy ${source} to ${destination}:`);
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		return false;
	}
}

/**
 * Safely writes a file with error handling.
 */
function safeWriteFile(filepath: string, content: string): boolean {
	try {
		// Ensure directory exists
		const dir = dirname(filepath);
		if (!existsSync(dir)) {
			mkdirSync(dir, { recursive: true });
		}

		writeFileSync(filepath, content);
		return true;
	} catch (error) {
		console.error(`‚ùå Failed to write ${filepath}:`);
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		return false;
	}
}

/**
 * Runs TypeScript type checking and returns whether it succeeded.
 * Provides detailed error reporting for type issues.
 */
async function runTypeCheck(): Promise<boolean> {
	console.log("üîç Running TypeScript type check...");
	
	try {
		// For production builds, use production TypeScript config that excludes test files
		const args = prod 
			? ["tsc", "--noEmit", "--skipLibCheck", "--project", "tsconfig.prod.json"]
			: ["bun", "run", "typecheck"];
		
		const proc = Bun.spawn(args, {
			stdout: "pipe",
			stderr: "pipe",
		});
		
		const result = await proc.exited;
		
		if (result !== 0) {
			const stderr = await new Response(proc.stderr).text();
			const stdout = await new Response(proc.stdout).text();
			
			console.error("‚ùå TypeScript type check failed:");
			if (stderr) console.error(stderr);
			if (stdout) console.error(stdout);
			
			console.error("\nüí° Fix type errors before continuing the build");
			return false;
		}
		
		console.log("‚úÖ TypeScript type check passed");
		return true;
	} catch (error) {
		console.error("‚ùå Failed to run TypeScript type check:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		return false;
	}
}

/**
 * Validates the generated plugin files to ensure they meet Obsidian's requirements.
 */
function validatePluginOutput(): boolean {
	// Check that main.js was generated and has content
	if (!existsSync("main.js")) {
		console.error("‚ùå Build output validation failed: main.js not found");
		return false;
	}
	
	try {
		const mainContent = require("fs").readFileSync("main.js", "utf-8");
		
		// Basic sanity checks for the generated plugin
		if (mainContent.length < 100) {
			console.error("‚ùå Build output validation failed: main.js appears to be empty or too small");
			return false;
		}
		
		// Check for essential plugin patterns (exports default, extends Plugin, etc.)
		// Bun uses CommonJS format, so we need to check for different export patterns
		const hasDefaultExport = /export\s*{\s*\w+\s+as\s+default\s*}|export\s+default|module\.exports\s*=/.test(mainContent);
		const hasPluginClass = /extends\s+Plugin|class\s+\w+Plugin|Plugin\s*{/.test(mainContent);
		
		if (!hasDefaultExport) {
			console.warn("‚ö†Ô∏è  Warning: main.js does not appear to have a default export");
		}
		
		if (!hasPluginClass) {
			console.warn("‚ö†Ô∏è  Warning: main.js does not appear to extend the Plugin class");
		}
		
		console.log(`‚úÖ Plugin output validation passed (${Math.round(mainContent.length / 1024)}KB)`);
		return true;
		
	} catch (error) {
		console.error("‚ùå Build output validation failed:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		return false;
	}
}

/**
 * Provides helpful suggestions for common development environment setup issues.
 */
function suggestEnvironmentSetup(): void {
	if (!prod && !process.env.OBSIDIAN_PLUGINS_PATH) {
		console.log("\nüí° Development tip: Set OBSIDIAN_PLUGINS_PATH to enable automatic plugin copying:");
		console.log("   export OBSIDIAN_PLUGINS_PATH=\"/path/to/your/vault/.obsidian/plugins\"");
		console.log("   Or create a .env file with: OBSIDIAN_PLUGINS_PATH=/path/to/your/vault/.obsidian/plugins");
		console.log("\n   Common paths:");
		console.log("   macOS: ~/Documents/YourVault/.obsidian/plugins");
		console.log("   Windows: %USERPROFILE%\\Documents\\YourVault\\.obsidian\\plugins");
		console.log("   Linux: ~/Documents/YourVault/.obsidian/plugins");
	}
}

const buildConfig = {
	entrypoints: ["./src/main.ts"],
	outdir: "./",
	target: "browser",
	format: "cjs" as const,
	sourcemap: prod ? "none" as const : "inline" as const,
	minify: prod,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab", 
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
	],
};

async function build() {
	const buildStartTime = Date.now();
	console.log(prod ? "üèóÔ∏è  Building for production..." : "üî® Building for development...");
	
	// Validate environment before building
	try {
		validateEnvironment();
	} catch (error) {
		console.error(`‚ùå Environment validation failed: ${error instanceof Error ? error.message : String(error)}`);
		process.exit(1);
	}
	
	// Run TypeScript type checking for production builds or if explicitly enabled
	if (prod || process.env.TYPECHECK_ON_BUILD === "true") {
		const typeCheckStartTime = Date.now();
		
		if (!(await runTypeCheck())) {
			console.error("‚ùå Build aborted due to type check failures");
			process.exit(1);
		}
		
		const typeCheckTime = Date.now() - typeCheckStartTime;
		console.log(`‚è±Ô∏è  Type check completed in ${typeCheckTime}ms`);
	}
	
	// Perform the build
	const bundleStartTime = Date.now();
	let result;
	try {
		result = await Bun.build(buildConfig);
	} catch (error) {
		console.error("‚ùå Build process failed:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		console.error("   This usually indicates a configuration or dependency issue");
		process.exit(1);
	}
	
	const bundleTime = Date.now() - bundleStartTime;
	
	if (!result.success) {
		console.error("‚ùå Build failed:");
		for (const message of result.logs) {
			console.error(`   ${message}`);
		}
		console.error("\nüí° Common solutions:");
		console.error("   - Check for TypeScript compilation errors");
		console.error("   - Verify all imports are correct");
		console.error("   - Run 'bun run typecheck' for detailed type errors");
		process.exit(1);
	}
	
	console.log(`‚è±Ô∏è  Bundling completed in ${bundleTime}ms`);

	// Write the bundled output with banner
	const mainOutput = result.outputs.find(output => output.path.endsWith("main.js"));
	if (mainOutput) {
		try {
			const content = banner + "\n" + await mainOutput.text();
			if (!safeWriteFile("main.js", content)) {
				console.error("‚ùå Failed to write main.js output file");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Failed to process build output:");
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			process.exit(1);
		}
	} else {
		console.error("‚ùå Build succeeded but main.js output not found in result");
		process.exit(1);
	}
	
	// Validate the plugin output
	if (!validatePluginOutput()) {
		console.error("‚ùå Build aborted due to output validation failures");
		process.exit(1);
	}

	// Handle development environment copying with comprehensive error handling
	if (!prod && process.env.OBSIDIAN_PLUGINS_PATH) {
		const pluginPath = join(process.env.OBSIDIAN_PLUGINS_PATH, "obsidian-operator");
		let copySuccess = true;
		
		try {
			// Ensure plugin directory exists
			if (!existsSync(pluginPath)) {
				mkdirSync(pluginPath, { recursive: true });
			}
			
			// Copy required files with error handling
			const filesToCopy = [
				{ source: "main.js", required: true },
				{ source: "manifest.json", required: true },
				{ source: "styles.css", required: false }
			];
			
			for (const file of filesToCopy) {
				if (file.required || existsSync(file.source)) {
					if (!safeCopyFile(file.source, join(pluginPath, file.source))) {
						if (file.required) {
							copySuccess = false;
							break;
						}
					}
				}
			}
			
			// Create .hotreload file for hot-reload plugin support
			if (copySuccess) {
				if (safeWriteFile(join(pluginPath, ".hotreload"), new Date().toISOString())) {
					console.log(`‚úì Successfully copied to ${pluginPath}`);
				} else {
					console.warn("‚ö†Ô∏è  Plugin files copied but .hotreload file creation failed");
				}
			}
			
		} catch (error) {
			console.error("‚ùå Failed to copy files to Obsidian plugins directory:");
			console.error(`   Plugin path: ${pluginPath}`);
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			console.error("   Build succeeded but plugin files were not copied");
			copySuccess = false;
		}
		
		if (!copySuccess) {
			console.error("\nüí° You can manually copy these files to your Obsidian vault:");
			console.error(`   cp main.js manifest.json styles.css "${pluginPath}/"`);
		}
	}

	// Provide helpful environment setup suggestions
	suggestEnvironmentSetup();

	const totalBuildTime = Date.now() - buildStartTime;
	console.log(`‚úÖ Build complete! (${totalBuildTime}ms total)`);
}

if (watch) {
	console.log("üëÄ Watching for changes...");
	
	// Initial build with error handling
	try {
		await build();
	} catch (error) {
		console.error("‚ùå Initial build failed, but continuing to watch for changes...");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
	}
	
	// Watch for changes in src and root files with debouncing
	const fs = require("fs");
	let watchers: any[] = [];
	let rebuildTimer: NodeJS.Timeout | null = null;
	let pendingChanges = new Set<string>();
	
	// Debounced rebuild function to prevent excessive rebuilds
	const debouncedBuild = async () => {
		if (pendingChanges.size === 0) return;
		
		const changes = Array.from(pendingChanges);
		pendingChanges.clear();
		
		console.log(`üìù ${changes.length} file(s) changed: ${changes.join(", ")}`);
		console.log("‚è±Ô∏è  Rebuilding...");
		
		try {
			await build();
		} catch (error) {
			console.error("‚ùå Rebuild failed:");
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			console.error("   Continuing to watch for changes...");
		}
	};
	
	// Function to schedule a debounced rebuild
	const scheduleRebuild = (filename: string) => {
		pendingChanges.add(filename);
		
		if (rebuildTimer) {
			clearTimeout(rebuildTimer);
		}
		
		rebuildTimer = setTimeout(debouncedBuild, 150); // 150ms debounce delay
	};
	
	try {
		// Watch src directory
		const srcWatcher = fs.watch("./src", { recursive: true }, async (eventType: string, filename: string) => {
			if (filename && (filename.endsWith(".ts") || filename.endsWith(".js"))) {
				scheduleRebuild(`src/${filename}`);
			}
		});
		watchers.push(srcWatcher);
		
		// Watch root files (styles.css, manifest.json)
		const rootFiles = ["styles.css", "manifest.json"];
		rootFiles.forEach(file => {
			if (fs.existsSync(file)) {
				const fileWatcher = fs.watchFile(file, async () => {
					scheduleRebuild(file);
				});
				watchers.push(() => fs.unwatchFile(file));
			}
		});
		
		console.log(`‚úì Watching ${watchers.length} file sources for changes...`);
		
	} catch (error) {
		console.error("‚ùå Failed to set up file watchers:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		console.error("   Falling back to single build...");
		process.exit(1);
	}
	
	// Graceful shutdown handling
	process.on("SIGINT", () => {
		console.log("\nüëã Stopping watchers...");
		
		// Clear any pending rebuild timer
		if (rebuildTimer) {
			clearTimeout(rebuildTimer);
		}
		
		// Clean up file watchers
		watchers.forEach(watcher => {
			try {
				if (typeof watcher === "function") {
					watcher(); // Cleanup function
				} else if (watcher && typeof watcher.close === "function") {
					watcher.close(); // Watcher object
				}
			} catch (error) {
				// Ignore cleanup errors
			}
		});
		console.log("‚úÖ Watchers stopped");
		process.exit(0);
	});
	
} else {
	// Single build mode with error handling
	try {
		await build();
	} catch (error) {
		console.error("‚ùå Build failed:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		process.exit(1);
	}
}
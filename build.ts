#!/usr/bin/env bun

import { existsSync, mkdirSync, copyFileSync, writeFileSync, accessSync, constants } from "fs";
import { join, dirname } from "path";
import { homedir } from "os";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY BUN
if you want to view the source, please visit the github repository of this plugin
https://github.com/karlmdavis/obsidian-operator
*/
`;

const args = process.argv.slice(2);
const prod = args.includes("--production");
const watch = args.includes("--watch");

/**
 * Validates the build environment and provides helpful error messages.
 * Checks for required tools, directories, and environment variables.
 */
function validateEnvironment(): void {
	// Check if we're in the right directory (has manifest.json)
	if (!existsSync("manifest.json")) {
		console.error("‚ùå Build failed: manifest.json not found. Are you running from the project root?");
		process.exit(1);
	}

	// Check if source directory exists
	if (!existsSync("src")) {
		console.error("‚ùå Build failed: src directory not found");
		process.exit(1);
	}

	// Check if main entry point exists
	if (!existsSync("src/main.ts")) {
		console.error("‚ùå Build failed: src/main.ts not found");
		process.exit(1);
	}

	// For development builds with copying, validate OBSIDIAN_PLUGINS_PATH
	if (!prod && process.env.OBSIDIAN_PLUGINS_PATH) {
		const pluginsPath = process.env.OBSIDIAN_PLUGINS_PATH;
		
		try {
			// Check if the parent directory exists and is writable
			accessSync(dirname(pluginsPath), constants.F_OK | constants.W_OK);
		} catch (error) {
			console.error(`‚ùå Environment setup error: OBSIDIAN_PLUGINS_PATH parent directory is not accessible:`);
			console.error(`   Path: ${dirname(pluginsPath)}`);
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			console.error(`   Suggestion: Check that the path exists and you have write permissions`);
			process.exit(1);
		}
	}
}

/**
 * Safely copies a file with error handling and helpful error messages.
 * Creates parent directories if they don't exist.
 */
function safeCopyFile(source: string, destination: string): boolean {
	try {
		// Ensure destination directory exists
		const destDir = dirname(destination);
		if (!existsSync(destDir)) {
			mkdirSync(destDir, { recursive: true });
		}

		// Check if source file exists
		if (!existsSync(source)) {
			console.warn(`‚ö†Ô∏è  Warning: Source file ${source} does not exist, skipping copy`);
			return false;
		}

		// Perform the copy
		copyFileSync(source, destination);
		return true;
	} catch (error) {
		console.error(`‚ùå Failed to copy ${source} to ${destination}:`);
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		return false;
	}
}

/**
 * Safely writes a file with error handling.
 */
function safeWriteFile(filepath: string, content: string): boolean {
	try {
		// Ensure directory exists
		const dir = dirname(filepath);
		if (!existsSync(dir)) {
			mkdirSync(dir, { recursive: true });
		}

		writeFileSync(filepath, content);
		return true;
	} catch (error) {
		console.error(`‚ùå Failed to write ${filepath}:`);
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		return false;
	}
}

/**
 * Provides helpful suggestions for common development environment setup issues.
 */
function suggestEnvironmentSetup(): void {
	if (!prod && !process.env.OBSIDIAN_PLUGINS_PATH) {
		console.log("\nüí° Development tip: Set OBSIDIAN_PLUGINS_PATH to enable automatic plugin copying:");
		console.log("   export OBSIDIAN_PLUGINS_PATH=\"/path/to/your/vault/.obsidian/plugins\"");
		console.log("   Or create a .env file with: OBSIDIAN_PLUGINS_PATH=/path/to/your/vault/.obsidian/plugins");
		console.log("\n   Common paths:");
		console.log("   macOS: ~/Documents/YourVault/.obsidian/plugins");
		console.log("   Windows: %USERPROFILE%\\Documents\\YourVault\\.obsidian\\plugins");
		console.log("   Linux: ~/Documents/YourVault/.obsidian/plugins");
	}
}

const buildConfig = {
	entrypoints: ["./src/main.ts"],
	outdir: "./",
	target: "browser",
	format: "cjs" as const,
	sourcemap: prod ? "none" as const : "inline" as const,
	minify: prod,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab", 
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
	],
};

async function build() {
	console.log(prod ? "üèóÔ∏è  Building for production..." : "üî® Building for development...");
	
	// Validate environment before building
	try {
		validateEnvironment();
	} catch (error) {
		console.error(`‚ùå Environment validation failed: ${error instanceof Error ? error.message : String(error)}`);
		process.exit(1);
	}
	
	// Perform the build
	let result;
	try {
		result = await Bun.build(buildConfig);
	} catch (error) {
		console.error("‚ùå Build process failed:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		console.error("   This usually indicates a configuration or dependency issue");
		process.exit(1);
	}
	
	if (!result.success) {
		console.error("‚ùå Build failed:");
		for (const message of result.logs) {
			console.error(`   ${message}`);
		}
		console.error("\nüí° Common solutions:");
		console.error("   - Check for TypeScript compilation errors");
		console.error("   - Verify all imports are correct");
		console.error("   - Run 'bun run typecheck' for detailed type errors");
		process.exit(1);
	}

	// Write the bundled output with banner
	const mainOutput = result.outputs.find(output => output.path.endsWith("main.js"));
	if (mainOutput) {
		try {
			const content = banner + "\n" + await mainOutput.text();
			if (!safeWriteFile("main.js", content)) {
				console.error("‚ùå Failed to write main.js output file");
				process.exit(1);
			}
		} catch (error) {
			console.error("‚ùå Failed to process build output:");
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			process.exit(1);
		}
	} else {
		console.error("‚ùå Build succeeded but main.js output not found in result");
		process.exit(1);
	}

	// Handle development environment copying with comprehensive error handling
	if (!prod && process.env.OBSIDIAN_PLUGINS_PATH) {
		const pluginPath = join(process.env.OBSIDIAN_PLUGINS_PATH, "obsidian-operator");
		let copySuccess = true;
		
		try {
			// Ensure plugin directory exists
			if (!existsSync(pluginPath)) {
				mkdirSync(pluginPath, { recursive: true });
			}
			
			// Copy required files with error handling
			const filesToCopy = [
				{ source: "main.js", required: true },
				{ source: "manifest.json", required: true },
				{ source: "styles.css", required: false }
			];
			
			for (const file of filesToCopy) {
				if (file.required || existsSync(file.source)) {
					if (!safeCopyFile(file.source, join(pluginPath, file.source))) {
						if (file.required) {
							copySuccess = false;
							break;
						}
					}
				}
			}
			
			// Create .hotreload file for hot-reload plugin support
			if (copySuccess) {
				if (safeWriteFile(join(pluginPath, ".hotreload"), new Date().toISOString())) {
					console.log(`‚úì Successfully copied to ${pluginPath}`);
				} else {
					console.warn("‚ö†Ô∏è  Plugin files copied but .hotreload file creation failed");
				}
			}
			
		} catch (error) {
			console.error("‚ùå Failed to copy files to Obsidian plugins directory:");
			console.error(`   Plugin path: ${pluginPath}`);
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			console.error("   Build succeeded but plugin files were not copied");
			copySuccess = false;
		}
		
		if (!copySuccess) {
			console.error("\nüí° You can manually copy these files to your Obsidian vault:");
			console.error(`   cp main.js manifest.json styles.css "${pluginPath}/"`);
		}
	}

	// Provide helpful environment setup suggestions
	suggestEnvironmentSetup();

	console.log("‚úÖ Build complete!");
}

if (watch) {
	console.log("üëÄ Watching for changes...");
	
	// Initial build with error handling
	try {
		await build();
	} catch (error) {
		console.error("‚ùå Initial build failed, but continuing to watch for changes...");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
	}
	
	// Watch for changes in src and root files
	const fs = require("fs");
	let watchers: any[] = [];
	
	try {
		// Watch src directory
		const srcWatcher = fs.watch("./src", { recursive: true }, async (eventType: string, filename: string) => {
			if (filename && (filename.endsWith(".ts") || filename.endsWith(".js"))) {
				console.log(`üìù ${filename} changed, rebuilding...`);
				try {
					await build();
				} catch (error) {
					console.error("‚ùå Rebuild failed:");
					console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
					console.error("   Continuing to watch for changes...");
				}
			}
		});
		watchers.push(srcWatcher);
		
		// Watch root files (styles.css, manifest.json)
		const rootFiles = ["styles.css", "manifest.json"];
		rootFiles.forEach(file => {
			if (fs.existsSync(file)) {
				const fileWatcher = fs.watchFile(file, async () => {
					console.log(`üìù ${file} changed, rebuilding...`);
					try {
						await build();
					} catch (error) {
						console.error("‚ùå Rebuild failed:");
						console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
						console.error("   Continuing to watch for changes...");
					}
				});
				watchers.push(() => fs.unwatchFile(file));
			}
		});
		
		console.log(`‚úì Watching ${watchers.length} file sources for changes...`);
		
	} catch (error) {
		console.error("‚ùå Failed to set up file watchers:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		console.error("   Falling back to single build...");
		process.exit(1);
	}
	
	// Graceful shutdown handling
	process.on("SIGINT", () => {
		console.log("\nüëã Stopping watchers...");
		watchers.forEach(watcher => {
			try {
				if (typeof watcher === "function") {
					watcher(); // Cleanup function
				} else if (watcher && typeof watcher.close === "function") {
					watcher.close(); // Watcher object
				}
			} catch (error) {
				// Ignore cleanup errors
			}
		});
		console.log("‚úÖ Watchers stopped");
		process.exit(0);
	});
	
} else {
	// Single build mode with error handling
	try {
		await build();
	} catch (error) {
		console.error("‚ùå Build failed:");
		console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
		process.exit(1);
	}
}
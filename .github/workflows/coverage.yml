name: Test Coverage

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  # Improve performance by skipping unnecessary Git operations
  DISABLE_ESLINT_PLUGIN: true
  CI: true

jobs:
  coverage:
    name: Test Coverage Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      pull-requests: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Fetch full history for coverage comparison
        fetch-depth: 0

    - name: Setup Bun
      uses: oven-sh/setup-bun@v2
      with:
        bun-version: latest

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.bun/install/cache
          node_modules
        key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb') }}
        restore-keys: |
          ${{ runner.os }}-bun-

    - name: Install dependencies
      run: bun install --frozen-lockfile

    - name: Run quality checks with coverage
      run: bun run ci:coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: obsidian-operator-coverage
        fail_ci_if_error: false # Don't fail if Codecov is down
        verbose: true
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    - name: Upload coverage to Coveralls (alternative)
      if: failure() # Run if Codecov fails
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        path-to-lcov: ./coverage/lcov.info

    - name: Generate coverage badge data
      if: github.ref == 'refs/heads/main'
      run: |
        # Install lcov for coverage analysis
        sudo apt-get update && sudo apt-get install -y lcov
        
        SUMMARY=$(lcov --summary coverage/lcov.info 2>/dev/null | grep "lines" | tail -1)
        
        if [ -n "$SUMMARY" ]; then
          COVERAGE_PCT=$(echo "$SUMMARY" | grep -o '[0-9.]*%' | head -1 | tr -d '%')
          
          # Determine badge color based on coverage
          if (( $(echo "$COVERAGE_PCT >= 90" | bc -l) )); then
            COLOR="brightgreen"
          elif (( $(echo "$COVERAGE_PCT >= 80" | bc -l) )); then
            COLOR="green"
          elif (( $(echo "$COVERAGE_PCT >= 70" | bc -l) )); then
            COLOR="yellow"
          elif (( $(echo "$COVERAGE_PCT >= 60" | bc -l) )); then
            COLOR="orange"
          else
            COLOR="red"
          fi
          
          echo "Coverage: ${COVERAGE_PCT}% (${COLOR})"
          echo "COVERAGE_PCT=${COVERAGE_PCT}" >> $GITHUB_ENV
          echo "BADGE_COLOR=${COLOR}" >> $GITHUB_ENV
        fi

    - name: Comment PR with coverage report
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const { execSync } = require('child_process');
          
          try {
            // Parse LCOV data for coverage information
            const lcovData = fs.readFileSync('./coverage/lcov.info', 'utf8');
            
            // Simple LCOV parsing to get coverage stats
            const lines = lcovData.split('\n');
            let totalLines = 0, coveredLines = 0;
            let totalFunctions = 0, coveredFunctions = 0;
            
            for (const line of lines) {
              if (line.startsWith('DA:')) {
                totalLines++;
                if (!line.endsWith(',0')) coveredLines++;
              }
              if (line.startsWith('FNH:')) {
                coveredFunctions += parseInt(line.split(':')[1]);
              }
              if (line.startsWith('FNF:')) {
                totalFunctions += parseInt(line.split(':')[1]);
              }
            }
            
            const lineCoverage = totalLines > 0 ? ((coveredLines / totalLines) * 100).toFixed(2) : 0;
            const functionCoverage = totalFunctions > 0 ? ((coveredFunctions / totalFunctions) * 100).toFixed(2) : 0;
            
            const formatPercentage = (pct) => {
              const num = parseFloat(pct);
              const color = num >= 90 ? '🟢' : num >= 80 ? '🟡' : num >= 70 ? '🟠' : '🔴';
              return `${color} ${pct}%`;
            };
            
            const comment = `## 📊 Coverage Report
            
            | Type | Coverage | Threshold | Status |
            |------|----------|-----------|--------|
            | **Lines** | ${formatPercentage(lineCoverage)} | 80% | ${parseFloat(lineCoverage) >= 80 ? '✅' : '❌'} |
            | **Functions** | ${formatPercentage(functionCoverage)} | 80% | ${parseFloat(functionCoverage) >= 80 ? '✅' : '❌'} |
            
            ### 📈 Coverage Details
            
            - **Total Lines**: ${coveredLines}/${totalLines}
            - **Total Functions**: ${coveredFunctions}/${totalFunctions}
            
            <details>
            <summary>📋 View file coverage summary</summary>
            
            \`\`\`
            Lines with coverage data: ${totalLines}
            Functions with coverage data: ${totalFunctions}
            \`\`\`
            
            </details>
            
            ---
            *Coverage report generated by [Bun](https://bun.sh) • [View full report on Codecov](https://codecov.io/github/${{ github.repository }})*`;
            
            // Find existing coverage comment
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes('📊 Coverage Report')
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
          } catch (error) {
            console.error('Error processing coverage data:', error);
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '❌ Unable to generate coverage report. Please check the workflow logs.'
            });
          }

    - name: Archive coverage reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-reports
        path: |
          coverage/
        retention-days: 30

  # Separate job for coverage trend analysis
  coverage-trends:
    name: Coverage Trends
    runs-on: ubuntu-latest
    needs: coverage
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download coverage reports
      uses: actions/download-artifact@v4
      with:
        name: coverage-reports
        path: ./coverage

    - name: Analyze coverage trends
      run: |
        echo "Analyzing coverage trends..."
        
        # This is a placeholder for trend analysis
        # In practice, you'd store historical coverage data
        # and compare with previous runs
        
        if [ -f "./coverage/lcov.info" ]; then
          echo "Coverage data available for trend analysis"
          
          # Simple trend logging
          mkdir -p .coverage-history
          echo "{\"date\": \"$(date -I)\", \"commit\": \"${{ github.sha }}\", \"branch\": \"${{ github.ref_name }}\"}" >> .coverage-history/$(date -I).json
          
          echo "✅ Coverage trend analysis completed"
        else
          echo "⚠️ No coverage data available"
        fi